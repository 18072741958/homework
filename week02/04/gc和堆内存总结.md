一、GC背景和原理
1、为什么会有GC：内存资源的有限性，需要共享使用，手动申请，手动释放；
2、判断是否为垃圾：
1）引用计数：存在循环引用，形成一个环
2）可达性分析（引用跟踪）：标记清除算法（Mark and Sweep），标记整理算法->并行GC和CMS的基本原理
GC root根对象：
1）当前正在执行的方法里的局部变量和输入参数；
2）活动线程；
3）所有类的静态字段（static field）
4）JNI引用：少见
3、分代假设中，不同分代对象存活时间不同，年轻代对象存活时间短(标记复制算法)，老年代对象存活时间长（标记清除和标记整理算法），需要使用不同的GC算法
默认年轻代15次GC后还存活的对象，放入老年代
4、GC暂停的时间，与堆内存大小和对象的总数没有直接关系，而是由存活对象的数量来决定，所有增加堆内存的大小并不会影响标记阶段占用的时间
5、算法：
1）标记清除算法（mark-sweep）：内存碎片问题
2）标记复制算法（mark-copy）：年轻代，浪费一半survivor区空间
3）标记整理算法(mark-sweep-compact)

二、串行GC和并行GC
1、串行GC（SerialGC）：-XX:+UseSerialGC配置，年轻代mark-copy算法，老年代mark-sweep-compact算法
1）简单原始，单线程，GC过程全程触发全线暂停（STW），停止所有应用线程，只能使用单核，暂停时间长
2）适用几百MB堆内存的jvm，单核cpu比较有用
3）-XX:+UseParNewGC改进版本的Serial GC,并行GC，配合CMS使用

2、并行GC（Parallel GC）：JDK6、7、8 默认GC，Java9默认GC为G1，-XX:+UseParallelGC等
1）年轻代和老年代的垃圾回收都会触发STW，年轻代mark-copy算法，老年代mark-sweep-compact算法
2）多个线程同时进行垃圾回收，-XX:ParallelGCThreads=N来指定GC线程数，默认为CPU核心数，使用所有cpu线程
3）适用于多核服务器，增加吞吐量

三、CMS GC：-XX:UseConcMarkSweepGC，并发算法
1）年轻代mark-copy算法，老年代mark-sweep算法，不对老年代进行整理，使用空闲列表来管理内存空间的回收
2）在标记清除阶段的大部分工作和应用线程一起并发执行，不会全程STW，默认CMS的并发线程为CPU核心数的1/4
3）降低gc停顿导致的系统延迟，适用于多核服务器，对系统延迟有要求的系统
4）CMS老年代的GC会发生与应用线程争抢cpu资源，进行老年代的并发回收时，可能会伴随多次年轻代的minor GC
cms六个阶段：
1）初始标记；STW，标记所有的根对象，以及根对象直接引用的对象，以及年轻代中所有存活对象所引用的老年代对象
2）并发标记:
3）并发预清理：
4）最终标记：STW，young区对象比较少得时候做
5）并发清除：
6）并发重置
优点：大部分阶段多线程并发执行
缺点：内存碎片

四、G1 GC：-XX：UseG1GC -XX:MaxGCPauseMills=50（默认200ms）
1、Garbage-First，垃圾优先，哪一块垃圾最多就优先清理；年轻代mark-copy算法，老年代mark-sweep-compact算法，
2、将STW停顿的时间，变成可预期和可配置的，增量式处理垃圾，控制暂停时间（尽量做到），在吞吐量和暂停时间寻找平衡；
3、不再区分年轻代和老年代，划分为多个小块：region（通常为2048个），每个小块，可能一会被定义成Eden，一会被定义成survivor或者old
4、多线程并发，和应用线程并发执行；
5、每次回收，只处理一部分内存块，会回收所有年轻代的内存块和部分老年代的内存块，垃圾最多的小块会被优先收集；
6、IHOP：G1内部并行回收循环启动的阈值，默认为java堆的45%，堆内存使用大于等于45%时，开始启动老年代的并行回收
7、注意事项：某些情况下，G1触发FullGC，会退化成serialGC进行垃圾收集，暂停时间长；
1）G1启动标记周期，但在MixGc之前，老年代就被填满，这时候G1放弃标记周期；
解决办法：增加堆大小，增加GC线程数
2）晋升失败，没有足够的内存供存活对象或晋升对象使用，由此触发Full GC：减小IHOP，增加GC线程数
3）巨型对象分配失败：增加内存，增大每个小块大小

五：ZGC：java11引入，与应用线程并发
1、暂停时间非常短；控制住10ms以内；
2、堆内存支持范围广，几百MB到4TB；
3、与G1相比，应用吞吐量下降不超过15%
4、适用于堆内存比较大，对系统延迟有要求；

六、ShennandoahGC：java12引入，与应用线程并发
1、young区清理也并发；

串行GC(SerialGC):单线程执行，应用需要暂停；
并行GC（ParNew，Parallel Scanvenge，Parallel Old）：多线程并行的执行垃圾回收，关注高吞吐；
CMS：多线程并发标记和清除，关注与降低延迟；
G1：多线程并发,通过划分多个内存区域做增量整理和回收，进一步降低延迟；
ZGC：多线程并发,通过着色指针和读屏障，实现几乎全部的并发执行，几毫秒的延迟，线性可扩展，吞吐量比G1有所下降；
Shenandoah：多线程并发,G1的改进版本，跟ZGC类似;
Epsilon:实验性的GC，供性能分析使用

GC组合：
1）Serial + Serial Old）：单线程低延迟的垃圾回收；
2）ParNeW + CMS:实现多线程低延迟并发的垃圾回收
3）Parallel Scanvenge，Parallel old:实现多线程并行的高吞吐量（业务线程）的垃圾回收

吞吐优先：并行GC；
低延迟：CMS GC
堆内存较大，同时希望整体的平均GC时间可控，使用G1
对于内存：
1）一般4G算是比较大，用G1的性价比比较高；
2）一般超过8G，比如16G-64G，非常推荐使用G1 